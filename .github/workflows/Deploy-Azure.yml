name: Deploy to Azure

on:
    push:
        branches:
            - '*'

permissions:
    id-token: write
    contents: read

env:
    RESOURCE_GROUP: RG-CALL_FOR_CODE-MARCH
    LOCATION: francecentral
    VM_NAME: callforcode-${{ github.ref_name }}
    VM_ADMIN: azureuser
    VM_IMAGE: UbuntuLTS
    VM_SIZE: Standard_B2s
    PUBLIC_IP_NAME: callforcode-${{ github.ref_name }}-ip
    VM_IP: ''

jobs:
    deploy:
        runs-on: ubuntu-latest

        steps:
            - name: Checkout repository
              uses: actions/checkout@v3

            - name: Login to Azure with SP
              uses: azure/login@v1
              with:
                creds: ${{ secrets.AZURE_CREDENTIALS }}

            - name: Create Azure VM if not exists
              run: |
                  echo "Vérification et création de la VM si nécessaire..."
                  
                  VM_EXISTS=$(az vm list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?name=='${{ env.VM_NAME }}'].name" -o tsv)
                  
                  if [[ -z "$VM_EXISTS" ]]; then
                    echo "Création de la VM..."
                    az vm create --resource-group ${{ env.RESOURCE_GROUP }} --name ${{ env.VM_NAME }} \
                      --image ${{ env.VM_IMAGE }} --size ${{ env.VM_SIZE }} --admin-username ${{ env.VM_ADMIN }} \
                      --admin-password ${{ secrets.AZURE_VM_PASSWORD }} --public-ip-address ${{ env.PUBLIC_IP_NAME }} --custom-data cloud-init.txt
                  else
                    echo "La VM existe déjà."
                  fi

                  - name: Get VM Public IP
                  run: |
                    echo "Récupération de l'IP publique de la VM..."
                    VM_IP=$(az vm show --resource-group ${{ env.RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --show-details --query publicIps -o tsv)
                    echo "VM_IP=$VM_IP" >> $GITHUB_ENV
    
            - name: Wait for VM to be ready
              run: |
                    echo "Attente que la VM soit accessible en SSH..."
                    sleep 30
                    while ! nc -z ${{ env.VM_IP }} 22; do   
                      echo "Attente..."
                      sleep 5
                    done
                    echo "La VM est accessible."

            - name: Install Docker and Docker Compose on VM
              run: |
                      echo "Installation de Docker et Docker Compose sur la VM..."
                      sshpass -p "${{ secrets.AZURE_VM_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VM_ADMIN }}@${{ env.VM_IP }} << 'EOF'
                        sudo apt-get update -y
                        sudo apt-get install -y docker.io
                        sudo systemctl start docker
                        sudo systemctl enable docker
                        sudo usermod -aG docker $USER
                        sudo apt-get install -y docker-compose
                      EOF

            - name: Push Docker Compose to VM
              run: |
                    echo "Envoi du fichier docker-compose.yml à la VM..."
                    sshpass -p "${{ secrets.AZURE_VM_PASSWORD }}" scp -o StrictHostKeyChecking=no -r API/docker-compose.yml ${{ env.VM_ADMIN }}@${{ env.VM_IP }}:/home/${{ env.VM_ADMIN }}/
        
            - name: Deploy Docker Compose on VM
              run: |
                echo "Déploiement de l'application avec Docker Compose..."
                sshpass -p "${{ secrets.AZURE_VM_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VM_ADMIN }}@${{ env.VM_IP }} << 'EOF'
                  cd /home/${{ env.VM_ADMIN }}/
                  docker-compose down || true
                  docker-compose up -d
                EOF
        
            - name: Verify Deployment
              run: |
                echo "✅ Vérification que les conteneurs sont bien démarrés..."
                sshpass -p "${{ secrets.AZURE_VM_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VM_ADMIN }}@${{ env.VM_IP }} "docker ps"









            - name: Login to Azure Container Registry (ACR)
              run: |
                echo "${{ secrets.AZURE_ACR_PASSWORD }}" | docker login ${{ secrets.AZURE_ACR_SERVER }} -u ${{ secrets.AZURE_ACR_USERNAME }} --password-stdin
          
            - name: Normalize branch name for DNS
              run: |
                CLEAN_BRANCH_NAME=$(echo "${{ github.ref_name }}" | tr '[:upper:]' '[:lower:]' | tr -cd 'a-z0-9-' | sed 's/^-*//g' | sed 's/-*$//g' | cut -c1-63)
                echo "CLEAN_BRANCH_NAME=$CLEAN_BRANCH_NAME" >> $GITHUB_ENV
              
            - name: Delete existing container (if exists)
              run: |
                az container delete --resource-group ${{ env.RESOURCE_GROUP }} --name callforcode-${{ env.CLEAN_BRANCH_NAME }} --yes || true
                
          
            - name: Build and push Docker image
              run: |
                export COMPOSE_DOCKER_CLI_BUILD=1
                export DOCKER_BUILDKIT=1
                docker-compose -f $DOCKER_COMPOSE_FILE build
                docker-compose -f $DOCKER_COMPOSE_FILE push

              
            - name: Create ACI with Contribute first
              run: |
                az container create \
                  --resource-group $RESOURCE_GROUP \
                  --name my-api-container \
                  --file $DOCKER_COMPOSE_FILE \
                  --registry-login-server $ACR_SERVER \
                   --registry-username ${{ secrets.AZURE_ACR_USERNAME }} \
                  --registry-password ${{ secrets.AZURE_ACR_PASSWORD }}
    
            - name: Verify Deployment
              run: |
                    STATUS=$(az container show --resource-group ${{ env.RESOURCE_GROUP }} --name callforcode-${{ env.CLEAN_BRANCH_NAME }} --query "instanceView.state" -o tsv)
                    echo "État du conteneur : $STATUS"
                    if [[ "$STATUS" != "Running" ]]; then
                        echo "Déploiement échoué, vérifiez les logs sur Azure."
                        exit 1
                    fi